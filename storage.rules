rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {

    function isProfessor() {
      return request.auth != null && request.auth.token.role == 'professor';
    }

    // Helper function to safely check for ownership via file metadata
    function isOwner(fileResource) {
      return (fileResource.metadata != null &&
             'ownerId' in fileResource.metadata &&
             fileResource.metadata.ownerId == request.auth.uid);
    }

    // Helper to check ownership via Firestore lookup (fallback if metadata is missing)
    function isOwnerViaFirestore(fileId) {
      return firestore.exists(/databases/(default)/documents/fileMetadata/$(fileId)) &&
             firestore.get(/databases/(default)/documents/fileMetadata/$(fileId)).data.ownerId == request.auth.uid;
    }

    match /public-assets/{allPaths=**} {
      allow read;
    }

    match /courses/{courseId}/media/{fileId} {

      // READ is allowed for the owner or the legacy admin
      allow read: if (isProfessor() && isOwner(resource))
                  || request.auth.token.email == 'profesor@profesor.cz';

      // CREATE is disallowed. Uploads must use signed URLs.
      allow create: if false;

      // DELETE is allowed for the owner, the legacy admin, OR if the user owns the Firestore record
      allow delete: if (isProfessor() && (isOwner(resource) || isOwnerViaFirestore(fileId)))
                    || request.auth.token.email == 'profesor@profesor.cz';
    }

    // Default deny all other paths
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}
